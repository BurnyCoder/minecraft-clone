<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Block World</title>
    <style>
        /* CSS styles remain the same */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #87CEEB; }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border: 1px solid black;
            border-radius: 50%; /* Make it a small dot */
            transform: translate(-50%, -50%);
            pointer-events: none; /* Allow clicks to pass through */
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
         #block-selector {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px;
            border-radius: 5px;
            display: flex;
            gap: 5px;
        }
        .block-option {
            width: 40px;
            height: 40px;
            border: 2px solid grey;
            cursor: pointer;
            background-size: cover; /* For potential textures later */
        }
        .block-option.selected {
            border-color: white;
            box-shadow: 0 0 10px yellow;
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none; /* Hidden by default */
            z-index: 100;
        }
        #message-box button {
            margin-top: 15px;
            padding: 8px 15px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Click to lock mouse pointer.<br>
        WASD: Move<br>
        Space: Jump<br>
        Shift: Descend<br>
        Mouse: Look<br>
        Left Click: Break Block<br>
        Right Click: Place Block<br>
        Scroll Wheel / 1-5: Select Block<br>
        ESC: Unlock mouse
    </div>
    <div id="crosshair">+</div>
    <div id="block-selector"></div>
    <div id="message-box">
        <p id="message-text"></p>
        <button id="message-ok">OK</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // --- Configuration ---
        const WORLD_SIZE_X = 20; // Width
        const WORLD_SIZE_Y = 10; // Height
        const WORLD_SIZE_Z = 20; // Depth
        const BLOCK_SIZE = 1;
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_SPEED = 5.0;
        const JUMP_VELOCITY = 8.0;
        const GRAVITY = -20.0;
        const REACH_DISTANCE = 5; // How far the player can interact with blocks

        // --- Block Types ---
        const blockTypes = {
            1: { name: 'Grass', color: 0x559020, topColor: 0x6A9F2A },
            2: { name: 'Dirt', color: 0x8B4513 },
            3: { name: 'Stone', color: 0x808080 },
            4: { name: 'Wood', color: 0x966F33 },
            5: { name: 'Leaves', color: 0x228B22, transparent: true, opacity: 0.8 },
        };
        let selectedBlockType = 1;

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let world = {}; let objects = [];
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let moveUp = false, moveDown = false;
        let lastTime = performance.now();
        const raycaster = new THREE.Raycaster();
        let currentIntersected = null;
        const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
        let highlightMesh = new THREE.Mesh(new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), highlightMaterial);
        highlightMesh.visible = false;

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 75);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(WORLD_SIZE_X / 2, WORLD_SIZE_Y + PLAYER_HEIGHT, WORLD_SIZE_Z / 2);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(50, 200, 100); scene.add(directionalLight);
            if (typeof THREE.PointerLockControls === 'undefined') { console.error("THREE.PointerLockControls is not defined."); showMessage("Error: Could not load controls.", 0); return; }
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            document.body.addEventListener('click', () => { if (!controls.isLocked) controls.lock(); });
            controls.addEventListener('lock', () => { document.getElementById('instructions').style.display = 'none'; });
            controls.addEventListener('unlock', () => { document.getElementById('instructions').style.display = 'block'; });
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            document.body.addEventListener('contextmenu', (event) => event.preventDefault()); document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);
            setupBlockSelector(); generateWorld(); scene.add(highlightMesh);
            document.getElementById('message-ok').addEventListener('click', hideMessage);
        }

        // --- World Generation ---
        function generateWorld() { console.log("Generating world..."); const blocksToCreate = []; for (let x = 0; x < WORLD_SIZE_X; x++) { for (let z = 0; z < WORLD_SIZE_Z; z++) { for (let y = 0; y < WORLD_SIZE_Y; y++) { let blockType = 0; if (y < WORLD_SIZE_Y / 2 - 1) blockType = 3; else if (y < WORLD_SIZE_Y / 2) blockType = 2; else if (y === Math.floor(WORLD_SIZE_Y / 2)) blockType = 1; if (blockType > 0) { const key = getBlockKey(x, y, z); world[key] = blockType; blocksToCreate.push({x, y, z, type: blockType}); } } } } addTreeData(5, Math.floor(WORLD_SIZE_Y / 2) + 1, 5, blocksToCreate); addTreeData(15, Math.floor(WORLD_SIZE_Y / 2) + 1, 15, blocksToCreate); addTreeData(8, Math.floor(WORLD_SIZE_Y / 2) + 1, 18, blocksToCreate); console.log(`Creating ${blocksToCreate.length} block meshes...`); blocksToCreate.forEach(blockData => createBlockMesh(blockData.x, blockData.y, blockData.z, blockData.type)); console.log(`World generation complete.`); }
        function addTreeData(x, y, z, blocksToCreate) { const trunkHeight = 3 + Math.floor(Math.random() * 3); for (let i = 0; i < trunkHeight; i++) { const blockY = y + i; if (blockY < WORLD_SIZE_Y * 2) { const key = getBlockKey(x, blockY, z); const existingIndex = blocksToCreate.findIndex(b => b.x === x && b.y === blockY && b.z === z); if (existingIndex > -1) blocksToCreate.splice(existingIndex, 1); world[key] = 4; blocksToCreate.push({x, y: blockY, z, type: 4}); } } const canopyY = y + trunkHeight; for (let lx = -2; lx <= 2; lx++) { for (let lz = -2; lz <= 2; lz++) { for (let ly = 0; ly <= 1; ly++) { if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue; if (ly === 1 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue; if (lx === 0 && lz === 0 && ly === 1) continue; const blockX = x + lx; const blockY = canopyY + ly; const blockZ = z + lz; const key = getBlockKey(blockX, blockY, blockZ); if (!world[key] && blockY < WORLD_SIZE_Y * 2) { world[key] = 5; blocksToCreate.push({x: blockX, y: blockY, z: blockZ, type: 5}); } } } } }
        function createBlockMesh(x, y, z, type) { const blockData = blockTypes[type]; if (!blockData) { console.error(`Invalid block type: ${type}`); return null; } const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); let material; if (type === 1 && blockData.topColor) { const mats = [ new THREE.MeshLambertMaterial({ color: blockData.color }), new THREE.MeshLambertMaterial({ color: blockData.color }), new THREE.MeshLambertMaterial({ color: blockData.topColor }), new THREE.MeshLambertMaterial({ color: 0x8B4513 }), new THREE.MeshLambertMaterial({ color: blockData.color }), new THREE.MeshLambertMaterial({ color: blockData.color }) ]; material = mats; } else { material = new THREE.MeshLambertMaterial({ color: blockData.color, transparent: blockData.transparent || false, opacity: blockData.opacity || 1.0, }); } const cube = new THREE.Mesh(geometry, material); cube.position.set(x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, z + BLOCK_SIZE / 2); cube.userData = { x, y, z, type }; scene.add(cube); objects.push(cube); return cube; }

        // --- Block Management ---
        function getBlockKey(x, y, z) { return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`; }
        function getBlock(x, y, z) { const key = getBlockKey(x, y, z); return world[key]; }
        function addBlock(x, y, z, type) {
            const key = getBlockKey(x, y, z);
            const MAX_BUILD_HEIGHT = 50;
            // Boundary check
            if (x < 0 || x >= WORLD_SIZE_X || y < 0 || y >= MAX_BUILD_HEIGHT || z < 0 || z >= WORLD_SIZE_Z) {
                console.warn(`Attempted to place block outside world boundaries at ${key}`);
                // showMessage("Cannot place block outside world bounds!"); // REMOVED
                return false; // Indicate failure
            }
            // Existing block check
            if (world[key]) {
                console.warn(`Block already exists at ${key}. Cannot place.`);
                // showMessage("Block already exists here!"); // REMOVED
                return false; // Indicate failure
            }
            // Add block data
            world[key] = type;
            // Create mesh
            const newMesh = createBlockMesh(x, y, z, type);
            return !!newMesh; // Return true if mesh creation succeeded
        }
        function removeBlock(x, y, z) { const key = getBlockKey(x, y, z); if (!world[key]) { return false; } delete world[key]; const idx = objects.findIndex(obj => obj.userData.x === x && obj.userData.y === y && obj.userData.z === z); if (idx !== -1) { const obj = objects[idx]; scene.remove(obj); if (obj.geometry) obj.geometry.dispose(); if (Array.isArray(obj.material)) { obj.material.forEach(mat => mat.dispose()); } else if (obj.material) { obj.material.dispose(); } objects.splice(idx, 1); return true; } else { console.warn(`Mesh not found at ${key}`); return false; } }

        // --- Player Movement & Physics ---
        function updatePlayer(delta) {
            if (!controls.isLocked) return;
            const playerPos = controls.getObject().position;
            velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
            velocity.y += GRAVITY * delta; velocity.y = Math.max(velocity.y, -50.0);
            direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft);
            const forwardDir = new THREE.Vector3(); const rightDir = new THREE.Vector3(); const moveDelta = new THREE.Vector3();
            camera.getWorldDirection(forwardDir); forwardDir.y = 0; forwardDir.normalize();
            rightDir.setFromMatrixColumn(camera.matrixWorld, 0); rightDir.y = 0; rightDir.normalize();
            if (direction.x !== 0 || direction.z !== 0) {
                moveDelta.addScaledVector(forwardDir, direction.z * PLAYER_SPEED * delta);
                moveDelta.addScaledVector(rightDir, direction.x * PLAYER_SPEED * delta);
            }
            playerPos.add(moveDelta);
            if (moveUp && canJump) { velocity.y = JUMP_VELOCITY; canJump = false; }
            if (moveDown) { playerPos.y -= PLAYER_SPEED * delta; velocity.y = Math.min(0, velocity.y); }
            playerPos.y += velocity.y * delta;
            // Collision Detection & Response
            const playerHalfHeight = PLAYER_HEIGHT / 2; const playerWidth = 0.4;
            const playerBox = new THREE.Box3(); let onGround = false; let correctedY = false;
            const checkMinX = Math.floor(playerPos.x - playerWidth / 2 - 1); const checkMaxX = Math.ceil(playerPos.x + playerWidth / 2 + 1);
            const checkMinY = Math.floor(playerPos.y - playerHalfHeight - 1); const checkMaxY = Math.ceil(playerPos.y + playerHalfHeight + 1);
            const checkMinZ = Math.floor(playerPos.z - playerWidth / 2 - 1); const checkMaxZ = Math.ceil(playerPos.z + playerWidth / 2 + 1);
            const blockBox = new THREE.Box3();
            for (let x = checkMinX; x < checkMaxX; x++) { for (let y = checkMinY; y < checkMaxY; y++) { for (let z = checkMinZ; z < checkMaxZ; z++) {
                const blockType = getBlock(x, y, z);
                if (blockType) {
                    blockBox.min.set(x, y, z); blockBox.max.set(x + BLOCK_SIZE, y + BLOCK_SIZE, z + BLOCK_SIZE);
                    playerBox.setFromCenterAndSize(playerPos, new THREE.Vector3(playerWidth, PLAYER_HEIGHT, playerWidth));
                    if (playerBox.intersectsBox(blockBox)) {
                        const deltaX = playerPos.x - (x + BLOCK_SIZE / 2); const deltaY = playerPos.y - (y + BLOCK_SIZE / 2); const deltaZ = playerPos.z - (z + BLOCK_SIZE / 2);
                        const penetrationX = (playerWidth / 2 + BLOCK_SIZE / 2) - Math.abs(deltaX); const penetrationY = (PLAYER_HEIGHT / 2 + BLOCK_SIZE / 2) - Math.abs(deltaY); const penetrationZ = (playerWidth / 2 + BLOCK_SIZE / 2) - Math.abs(deltaZ);
                        if (penetrationY < penetrationX && penetrationY < penetrationZ) {
                            if (deltaY > 0) { playerPos.y = blockBox.max.y + playerHalfHeight; if (velocity.y < 0) { velocity.y = 0; onGround = true; } }
                            else { playerPos.y = blockBox.min.y - playerHalfHeight; if (velocity.y > 0) { velocity.y = 0; } }
                            correctedY = true;
                        } else if (penetrationX < penetrationZ) {
                            if (deltaX > 0) { playerPos.x = blockBox.max.x + playerWidth / 2; } else { playerPos.x = blockBox.min.x - playerWidth / 2; } velocity.x = 0;
                        } else {
                            if (deltaZ > 0) { playerPos.z = blockBox.max.z + playerWidth / 2; } else { playerPos.z = blockBox.min.z - playerWidth / 2; } velocity.z = 0;
                        }
                        controls.getObject().position.set(playerPos.x, playerPos.y, playerPos.z);
                    }
                }
            }}}
            canJump = onGround;
            if (playerPos.y < -20) { playerPos.set(WORLD_SIZE_X / 2, WORLD_SIZE_Y + PLAYER_HEIGHT, WORLD_SIZE_Z / 2); velocity.set(0, 0, 0); showMessage("Fell out of the world!"); }
        }


        // --- Interaction ---
        function checkInteraction() { if (!controls.isLocked) { highlightMesh.visible = false; currentIntersected = null; return; } raycaster.setFromCamera({ x: 0, y: 0 }, camera); const intersects = raycaster.intersectObjects(objects, false); const previouslyIntersected = currentIntersected; currentIntersected = null; if (intersects.length > 0) { for (let i = 0; i < intersects.length; i++) { if (intersects[i].distance < REACH_DISTANCE) { const obj = intersects[i].object; if (obj.userData && obj.userData.x !== undefined) { currentIntersected = obj; if (previouslyIntersected !== currentIntersected) { highlightMesh.position.copy(obj.position); highlightMesh.visible = true; } break; } } } } if (!currentIntersected) { highlightMesh.visible = false; } else if (!highlightMesh.visible) { highlightMesh.position.copy(currentIntersected.position); highlightMesh.visible = true; } }
        function placeBlock() {
            if (!controls.isLocked || !currentIntersected) return;
            const blockPos = currentIntersected.userData;
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const intersects = raycaster.intersectObject(currentIntersected, false);
            if (!intersects || intersects.length === 0 || !intersects[0].face) { console.warn("Placement failed: No face normal."); return; }
            const face = intersects[0].face;
            const normal = face.normal.clone();
            const newBlockPos = { x: blockPos.x + Math.round(normal.x), y: blockPos.y + Math.round(normal.y), z: blockPos.z + Math.round(normal.z) };
            const playerPos = controls.getObject().position;
            const playerBox = new THREE.Box3().setFromCenterAndSize(playerPos, new THREE.Vector3(0.8, PLAYER_HEIGHT, 0.8));
            const newBlockBox = new THREE.Box3(new THREE.Vector3(newBlockPos.x, newBlockPos.y, newBlockPos.z), new THREE.Vector3(newBlockPos.x + BLOCK_SIZE, newBlockPos.y + BLOCK_SIZE, newBlockPos.z + BLOCK_SIZE));
            // Player collision check
            if (playerBox.intersectsBox(newBlockBox)) {
                console.log("Cannot place block inside player.");
                // showMessage("Cannot place block here!"); // REMOVED
                return;
            }
            // Attempt to add the block (addBlock handles other checks like bounds and existing blocks)
            addBlock(newBlockPos.x, newBlockPos.y, newBlockPos.z, selectedBlockType);
        }
        function breakBlock() { if (!controls.isLocked || !currentIntersected) return; const blockPos = currentIntersected.userData; const success = removeBlock(blockPos.x, blockPos.y, blockPos.z); if (success) { highlightMesh.visible = false; currentIntersected = null; } }

        // --- Event Handlers ---
        function onKeyDown(event) { if (!controls.isLocked && event.code !== 'Escape') return; switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = true; break; case 'ArrowLeft': case 'KeyA': moveLeft = true; break; case 'ArrowDown': case 'KeyS': moveBackward = true; break; case 'ArrowRight': case 'KeyD': moveRight = true; break; case 'Space': moveUp = true; break; case 'ShiftLeft': case 'ShiftRight': moveDown = true; break; case 'Escape': if (controls.isLocked) controls.unlock(); break; case 'Digit1': selectBlock(1); break; case 'Digit2': selectBlock(2); break; case 'Digit3': selectBlock(3); break; case 'Digit4': selectBlock(4); break; case 'Digit5': selectBlock(5); break; } }
        function onKeyUp(event) { switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = false; break; case 'ArrowLeft': case 'KeyA': moveLeft = false; break; case 'ArrowDown': case 'KeyS': moveBackward = false; break; case 'ArrowRight': case 'KeyD': moveRight = false; break; case 'Space': moveUp = false; break; case 'ShiftLeft': case 'ShiftRight': moveDown = false; break; } }
        function onMouseDown(event) { if (!controls.isLocked) return; switch (event.button) { case 0: breakBlock(); break; case 2: placeBlock(); break; } }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Block Selector UI ---
        function setupBlockSelector() { const selectorDiv = document.getElementById('block-selector'); selectorDiv.innerHTML = ''; Object.keys(blockTypes).sort().forEach(typeId => { const type = parseInt(typeId); const blockData = blockTypes[type]; const option = document.createElement('div'); option.classList.add('block-option'); option.dataset.type = type; option.style.backgroundColor = `#${blockData.color.toString(16).padStart(6, '0')}`; if (blockData.transparent) { option.style.opacity = '0.7'; option.style.borderStyle = 'dashed'; } option.title = `${type}: ${blockData.name}`; if (type === selectedBlockType) { option.classList.add('selected'); } option.addEventListener('click', () => { selectBlock(type); }); selectorDiv.appendChild(option); }); window.addEventListener('wheel', (event) => { const currentTypes = Object.keys(blockTypes).map(Number).sort(); const currentIndex = currentTypes.indexOf(selectedBlockType); if (currentIndex === -1) return; let nextIndex; if (event.deltaY < 0) { nextIndex = (currentIndex - 1 + currentTypes.length) % currentTypes.length; } else { nextIndex = (currentIndex + 1) % currentTypes.length; } selectBlock(currentTypes[nextIndex]); }, { passive: true }); }
        function selectBlock(type) { if (!blockTypes[type]) return; selectedBlockType = type; const options = document.querySelectorAll('.block-option'); options.forEach(opt => { opt.classList.toggle('selected', parseInt(opt.dataset.type) === selectedBlockType); }); }

        // --- Message Box ---
        let messageTimeout; function showMessage(text, duration = 2000) { const messageBox = document.getElementById('message-box'); const messageText = document.getElementById('message-text'); messageText.textContent = text; messageBox.style.display = 'block'; if (messageTimeout) clearTimeout(messageTimeout); messageTimeout = null; if (duration > 0) { messageTimeout = setTimeout(hideMessage, duration); } document.getElementById('message-ok').onclick = hideMessage; } function hideMessage() { if (messageTimeout) { clearTimeout(messageTimeout); messageTimeout = null; } document.getElementById('message-box').style.display = 'none'; document.getElementById('message-ok').onclick = null; }

        // --- Animation Loop ---
        function animate() { requestAnimationFrame(animate); const time = performance.now(); const delta = Math.min((time - lastTime) / 1000, 0.1); lastTime = time; if (delta > 0 && delta < 1.0) { updatePlayer(delta); checkInteraction(); } try { renderer.render(scene, camera); } catch(e) { console.error("Render error:", e); } }

        // --- Start ---
        window.onload = function() { if (typeof THREE === 'undefined') { console.error("THREE not defined."); alert("Error: Load Three.js failed."); return; } if (typeof THREE.PointerLockControls === 'undefined') { console.error("PointerLockControls not defined."); alert("Error: Load PointerLockControls failed."); return; } try { init(); animate(); } catch (error) { console.error("Init/Anim failed:", error); alert(`Error: ${error.message}.`); } }

    </script>
</body>
</html>
