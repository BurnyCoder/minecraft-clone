<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Block World</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #87CEEB; }
        canvas { display: block; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background-color: white; border: 1px solid black; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #instructions {
            position: absolute; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.5);
            color: white; padding: 10px; border-radius: 5px; font-size: 12px; z-index: 10;
        }
        /* Hotbar Styles */
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 2px; background-color: rgba(0, 0, 0, 0.4);
            padding: 4px; border-radius: 3px; border: 2px solid rgba(255,255,255,0.3);
        }
        .hotbar-slot {
            width: 44px; height: 44px; background-color: rgba(100, 100, 100, 0.5);
            border: 2px solid grey; cursor: pointer; position: relative;
            display: flex; align-items: center; justify-content: center;
            background-size: contain; /* For potential icons later */
            background-repeat: no-repeat;
            background-position: center;
            box-sizing: border-box; /* Include border in size */
        }
        .hotbar-slot.selected { border-color: white; border-width: 3px; }
        .hotbar-slot .slot-number {
            position: absolute; bottom: 1px; right: 3px; font-size: 10px;
            color: white; text-shadow: 1px 1px 1px black; pointer-events: none;
        }
        /* Block Preview inside Slot */
         .hotbar-slot .block-preview {
             width: 30px;
             height: 30px;
             border: 1px solid rgba(0,0,0,0.2);
         }

        #message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px;
            border-radius: 10px; text-align: center; display: none; z-index: 100;
        }
        #message-box button { margin-top: 15px; padding: 8px 15px; cursor: pointer; border: none; border-radius: 5px; background-color: #4CAF50; color: white; }

        /* Collected Blocks Counter */
        #collected-counter {
            position: absolute; top: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.5);
            color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px;
            max-height: 150px; overflow-y: auto; text-align: right;
        }
        #collected-counter div { margin-bottom: 2px; }

        /* Breaking progress indicator (remains conceptual for highlight opacity) */
    </style>
</head>
<body>
    <div id="instructions">
        Click to lock mouse pointer.<br>
        WASD: Move<br> Space: Jump<br> Shift: Descend<br> Mouse: Look<br>
        Hold Left Click: Break Block<br> Right Click: Place Block<br>
        Scroll Wheel / 1-9: Select Hotbar Slot<br> ESC: Unlock mouse
    </div>
    <div id="crosshair">+</div>
    <div id="hotbar"></div> <div id="collected-counter">Collected:</div> <div id="message-box"> <p id="message-text"></p> <button id="message-ok">OK</button> </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <script>
        // --- Configuration ---
        const WORLD_SIZE_X = 20; const WORLD_SIZE_Y = 10; const WORLD_SIZE_Z = 20;
        const BLOCK_SIZE = 1; const PLAYER_HEIGHT = 1.8; const PLAYER_SPEED = 5.0;
        const JUMP_VELOCITY = 8.0; const GRAVITY = -20.0; const REACH_DISTANCE = 5;
        const DAY_CYCLE_DURATION = 120; // Seconds for a full day-night cycle

        // --- Block Types ---
        // Added 'drops' property: null means doesn't drop, otherwise drops specified type ID
        const blockTypes = {
            1: { name: 'Grass', color: 0x559020, topColor: 0x6A9F2A, breakTime: 0.6, soundType: 'grass', drops: 2 }, // Drops Dirt
            2: { name: 'Dirt', color: 0x8B4513, breakTime: 0.5, soundType: 'dirt', drops: 2 },
            3: { name: 'Stone', color: 0x808080, breakTime: 1.5, soundType: 'stone', drops: 8 }, // Drops Cobblestone
            4: { name: 'Wood', color: 0x966F33, breakTime: 2.0, soundType: 'wood', drops: 4 },
            5: { name: 'Leaves', color: 0x228B22, transparent: true, opacity: 0.8, breakTime: 0.2, soundType: 'leaves', drops: null }, // Drops nothing (for now)
            6: { name: 'Sand', color: 0xF4A460, breakTime: 0.5, soundType: 'sand', hasGravity: true, drops: 6 },
            7: { name: 'Glass', color: 0xFFFFFF, transparent: true, opacity: 0.4, breakTime: 0.3, soundType: 'glass', drops: null }, // Drops nothing
            8: { name: 'Cobblestone', color: 0x708090, breakTime: 2.0, soundType: 'stone', drops: 8 },
            9: { name: 'Planks', color: 0xD2B48C, breakTime: 1.5, soundType: 'wood', drops: 9 }
        };
        let hotbarBlocks = [1, 2, 3, 8, 4, 9, 6, 7, 5]; // Default blocks in hotbar slots 1-9
        let selectedHotbarIndex = 0; // 0-8 corresponding to hotbarBlocks
        let selectedBlockType = hotbarBlocks[selectedHotbarIndex]; // Initial selected type

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let world = {}; let objects = [];
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let moveUp = false, moveDown = false;
        let lastTime = performance.now();
        const raycaster = new THREE.Raycaster();
        let currentIntersected = null; // Block data {x,y,z,type}
        const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
        let highlightMesh = new THREE.Mesh(new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), highlightMaterial);
        highlightMesh.visible = false;
        // Breaking state
        let isBreaking = false; let breakStartTime = 0; let currentBreakingBlock = null; let breakProgress = 0;
        // Sound Synths
        let synths = {};
        // Gravity Check List
        let gravityCheckQueue = new Set();
        // Day/Night Cycle
        let timeOfDay = 0.25; // Start at sunrise (0 = midnight, 0.25 = sunrise, 0.5 = noon, 0.75 = sunset)
        const skyColorDay = new THREE.Color(0x87CEEB);
        const skyColorNight = new THREE.Color(0x000033);
        const lightColorDay = new THREE.Color(0xffffff);
        const lightColorNight = new THREE.Color(0x444488);
        const fogColorDay = new THREE.Color(0x87CEEB);
        const fogColorNight = new THREE.Color(0x000033);
        // Footsteps
        let lastFootstepTime = 0;
        const footstepCooldown = 0.4; // Seconds between steps
        // Collected Blocks
        let collectedBlocks = {}; // { typeId: count }

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            // scene.background setup moved to updateDayNightCycle
            // scene.fog setup moved to updateDayNightCycle
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(WORLD_SIZE_X / 2, WORLD_SIZE_Y + PLAYER_HEIGHT, WORLD_SIZE_Z / 2);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            // Lighting setup moved to updateDayNightCycle, just add them here
            scene.add(new THREE.AmbientLight(0xcccccc, 0.5)); // Placeholder added
            scene.add(new THREE.DirectionalLight(0xffffff, 0.8)); // Placeholder added

            if (typeof THREE.PointerLockControls === 'undefined') { console.error("Controls missing."); showMessage("Error: Controls missing.", 0); return; }
            if (typeof Tone === 'undefined') { console.error("Tone.js missing."); showMessage("Error: Sound library missing.", 0); return; }
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            document.body.addEventListener('click', async () => {
                 if (!controls.isLocked) {
                     controls.lock();
                     if (Tone.context.state !== 'running') { await Tone.start(); console.log('Audio context started'); }
                 }
            });
            controls.addEventListener('lock', () => { document.getElementById('instructions').style.display = 'none'; });
            controls.addEventListener('unlock', () => { document.getElementById('instructions').style.display = 'block'; resetBreakingState(); });
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            document.body.addEventListener('contextmenu', (event) => event.preventDefault());
            document.addEventListener('mousedown', onMouseDown); document.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);

            setupHotbar(); // Changed from setupBlockSelector
            initSounds();
            generateWorld();
            scene.add(highlightMesh);
            updateCollectedUI(); // Initial UI update
            updateDayNightCycle(0); // Initial setup for lights/sky/fog
            document.getElementById('message-ok').addEventListener('click', hideMessage);
        }

        // --- Sound Initialization & Playback ---
        function initSounds() {
            synths.place = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination();
            synths.placeWood = new Tone.Synth({ oscillator: { type: 'square' }, volume: -8, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
            synths.placeStone = new Tone.Synth({ oscillator: { type: 'triangle' }, volume: -6, envelope: { attack: 0.02, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            synths.break = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination();
            synths.breakGlass = new Tone.NoiseSynth({ noise: { type: 'white' }, volume: -5, envelope: { attack: 0.001, decay: 0.05, sustain: 0 } }).toDestination();
            synths.breakLeaves = new Tone.NoiseSynth({ noise: { type: 'pink' }, volume: -15, envelope: { attack: 0.01, decay: 0.08, sustain: 0 } }).toDestination();
            synths.jump = new Tone.Synth({ oscillator: { type: 'triangle' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
            // Footsteps reuse place sounds but quieter/shorter
            synths.footstepWood = new Tone.Synth({ oscillator: { type: 'square' }, volume: -18, envelope: { attack: 0.01, decay: 0.05, sustain: 0.01, release: 0.05 } }).toDestination();
            synths.footstepStone = new Tone.Synth({ oscillator: { type: 'triangle' }, volume: -16, envelope: { attack: 0.02, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
            synths.footstepDirt = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -20, envelope: { attack: 0.01, decay: 0.08, sustain: 0.05, release: 0.1 } }).toDestination();
        }
        function playSound(type, note = 'C4', duration = '8n') {
            if (Tone.context.state !== 'running') return;
            if (synths[type]) {
                try {
                    if (type.startsWith('break')) synths[type].triggerAttackRelease(duration);
                    else synths[type].triggerAttackRelease(note, duration);
                } catch (e) { console.error("Tone.js error:", e); }
            } else console.warn(`Sound type "${type}" not found.`);
        }
        function playBlockSound(action, soundType) {
             if (action === 'place') {
                 if (soundType === 'wood') playSound('placeWood', 'A3', '16n');
                 else if (soundType === 'stone') playSound('placeStone', 'E3', '8n');
                 else playSound('place', 'C4', '8n');
             } else if (action === 'break') {
                 if (soundType === 'glass') playSound('breakGlass', null, '16n');
                 else if (soundType === 'leaves' || soundType === 'grass') playSound('breakLeaves', null, '8n');
                 else playSound('break', null, '8n');
             } else if (action === 'footstep') {
                  if (soundType === 'wood') playSound('footstepWood', 'C3', '16n');
                  else if (soundType === 'stone') playSound('footstepStone', 'G2', '16n');
                  else if (soundType === 'dirt' || soundType === 'grass' || soundType === 'sand') playSound('footstepDirt', 'A2', '16n');
                  // Add more cases for other ground types if needed
             }
        }

        // --- World Generation ---
        // (generateWorld, addTreeData, createBlockMesh functions remain the same)
        function generateWorld() { console.log("Generating world..."); const blocksToCreate = []; for (let x = 0; x < WORLD_SIZE_X; x++) { for (let z = 0; z < WORLD_SIZE_Z; z++) { for (let y = 0; y < WORLD_SIZE_Y; y++) { let blockType = 0; if (y < WORLD_SIZE_Y / 2 - 1) blockType = 3; else if (y < WORLD_SIZE_Y / 2) blockType = 2; else if (y === Math.floor(WORLD_SIZE_Y / 2)) blockType = 1; if (blockType > 0) { const key = getBlockKey(x, y, z); world[key] = blockType; blocksToCreate.push({x, y, z, type: blockType}); } } } } addTreeData(5, Math.floor(WORLD_SIZE_Y / 2) + 1, 5, blocksToCreate); addTreeData(15, Math.floor(WORLD_SIZE_Y / 2) + 1, 15, blocksToCreate); addTreeData(8, Math.floor(WORLD_SIZE_Y / 2) + 1, 18, blocksToCreate); console.log(`Creating ${blocksToCreate.length} block meshes...`); blocksToCreate.forEach(blockData => createBlockMesh(blockData.x, blockData.y, blockData.z, blockData.type)); console.log(`World generation complete.`); }
        function addTreeData(x, y, z, blocksToCreate) { const trunkHeight = 3 + Math.floor(Math.random() * 3); for (let i = 0; i < trunkHeight; i++) { const blockY = y + i; if (blockY < WORLD_SIZE_Y * 2) { const key = getBlockKey(x, blockY, z); const existingIndex = blocksToCreate.findIndex(b => b.x === x && b.y === blockY && b.z === z); if (existingIndex > -1) blocksToCreate.splice(existingIndex, 1); world[key] = 4; blocksToCreate.push({x, y: blockY, z, type: 4}); } } const canopyY = y + trunkHeight; for (let lx = -2; lx <= 2; lx++) { for (let lz = -2; lz <= 2; lz++) { for (let ly = 0; ly <= 1; ly++) { if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue; if (ly === 1 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue; if (lx === 0 && lz === 0 && ly === 1) continue; const blockX = x + lx; const blockY = canopyY + ly; const blockZ = z + lz; const key = getBlockKey(blockX, blockY, blockZ); if (!world[key] && blockY < WORLD_SIZE_Y * 2) { world[key] = 5; blocksToCreate.push({x: blockX, y: blockY, z: blockZ, type: 5}); } } } } }
        function createBlockMesh(x, y, z, type) { const blockData = blockTypes[type]; if (!blockData) { console.error(`Invalid block type: ${type}`); return null; } const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); let material; if (type === 1 && blockData.topColor) { const mats = [ new THREE.MeshLambertMaterial({ color: blockData.color }), new THREE.MeshLambertMaterial({ color: blockData.color }), new THREE.MeshLambertMaterial({ color: blockData.topColor }), new THREE.MeshLambertMaterial({ color: 0x8B4513 }), new THREE.MeshLambertMaterial({ color: blockData.color }), new THREE.MeshLambertMaterial({ color: blockData.color }) ]; material = mats; } else { material = new THREE.MeshLambertMaterial({ color: blockData.color, transparent: blockData.transparent || false, opacity: blockData.opacity || 1.0, }); } const cube = new THREE.Mesh(geometry, material); cube.position.set(x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, z + BLOCK_SIZE / 2); cube.userData = { x, y, z, type }; scene.add(cube); objects.push(cube); return cube; }

        // --- Block Management & Drops ---
        function getBlockKey(x, y, z) { return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`; }
        function getBlock(x, y, z) { const key = getBlockKey(x, y, z); return world[key]; }
        function addBlock(x, y, z, type, playSoundEffect = true) {
            const key = getBlockKey(x, y, z);
            const MAX_BUILD_HEIGHT = 50;
            if (x < 0 || x >= WORLD_SIZE_X || y < 0 || y >= MAX_BUILD_HEIGHT || z < 0 || z >= WORLD_SIZE_Z) return false;
            if (world[key]) return false;
            world[key] = type;
            const newMesh = createBlockMesh(x, y, z, type);
            if (newMesh && playSoundEffect) {
                const blockData = blockTypes[type];
                playBlockSound('place', blockData.soundType || 'default');
                scheduleGravityCheck(x, y - 1, z);
                if (blockData.hasGravity) { scheduleGravityCheck(x + 1, y, z); scheduleGravityCheck(x - 1, y, z); scheduleGravityCheck(x, y, z + 1); scheduleGravityCheck(x, y, z - 1); }
            }
            return !!newMesh;
        }
        function removeBlock(x, y, z, playSoundEffect = true) {
            const key = getBlockKey(x, y, z);
            const blockType = world[key];
            if (!blockType) { return false; }

            // --- Handle Block Drops ---
            const blockData = blockTypes[blockType];
            const droppedItemType = blockData?.drops; // Get the type ID of the item to drop
            if (droppedItemType !== null && droppedItemType !== undefined) {
                 collectedBlocks[droppedItemType] = (collectedBlocks[droppedItemType] || 0) + 1;
                 updateCollectedUI(); // Update the counter display
            }
            // --- End Handle Block Drops ---

            delete world[key];
            const idx = objects.findIndex(obj => obj.userData.x === x && obj.userData.y === y && obj.userData.z === z);
            if (idx !== -1) {
                const obj = objects[idx];
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (Array.isArray(obj.material)) { obj.material.forEach(mat => mat.dispose()); }
                else if (obj.material) { obj.material.dispose(); }
                objects.splice(idx, 1);
                if (playSoundEffect) { playBlockSound('break', blockData.soundType || 'default'); }
                scheduleGravityCheck(x, y + 1, z);
                scheduleGravityCheck(x + 1, y, z); scheduleGravityCheck(x - 1, y, z);
                scheduleGravityCheck(x, y, z + 1); scheduleGravityCheck(x, y, z - 1);
                return true;
            } else { console.warn(`Mesh not found at ${key}`); return false; }
        }

        // --- Player Movement & Physics ---
        function updatePlayer(delta) {
            if (!controls.isLocked) return;
            const playerPos = controls.getObject().position;
            const horizontalMovement = (moveForward || moveBackward || moveLeft || moveRight); // Check if trying to move

            velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
            velocity.y += GRAVITY * delta; velocity.y = Math.max(velocity.y, -50.0);
            direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft);
            const forwardDir = new THREE.Vector3(); const rightDir = new THREE.Vector3(); const moveDelta = new THREE.Vector3();
            camera.getWorldDirection(forwardDir); forwardDir.y = 0; forwardDir.normalize();
            rightDir.setFromMatrixColumn(camera.matrixWorld, 0); rightDir.y = 0; rightDir.normalize();
            if (direction.x !== 0 || direction.z !== 0) {
                moveDelta.addScaledVector(forwardDir, direction.z * PLAYER_SPEED * delta);
                moveDelta.addScaledVector(rightDir, direction.x * PLAYER_SPEED * delta);
            }
            playerPos.add(moveDelta);
            let didJump = false;
            if (moveUp && canJump) { velocity.y = JUMP_VELOCITY; canJump = false; didJump = true; }
            if (moveDown) { playerPos.y -= PLAYER_SPEED * delta; velocity.y = Math.min(0, velocity.y); }
            playerPos.y += velocity.y * delta;

            // Collision Detection & Response
            const playerHalfHeight = PLAYER_HEIGHT / 2; const playerWidth = 0.4;
            const playerBox = new THREE.Box3(); let onGround = false;
            const checkMinX = Math.floor(playerPos.x - playerWidth / 2 - 1); const checkMaxX = Math.ceil(playerPos.x + playerWidth / 2 + 1);
            const checkMinY = Math.floor(playerPos.y - playerHalfHeight - 1); const checkMaxY = Math.ceil(playerPos.y + playerHalfHeight + 1);
            const checkMinZ = Math.floor(playerPos.z - playerWidth / 2 - 1); const checkMaxZ = Math.ceil(playerPos.z + playerWidth / 2 + 1);
            const blockBox = new THREE.Box3();
            let groundBlockType = null; // Track block type under feet

            for (let x = checkMinX; x < checkMaxX; x++) { for (let y = checkMinY; y < checkMaxY; y++) { for (let z = checkMinZ; z < checkMaxZ; z++) {
                const blockType = getBlock(x, y, z);
                if (blockType) {
                    blockBox.min.set(x, y, z); blockBox.max.set(x + BLOCK_SIZE, y + BLOCK_SIZE, z + BLOCK_SIZE);
                    playerBox.setFromCenterAndSize(playerPos, new THREE.Vector3(playerWidth, PLAYER_HEIGHT, playerWidth));
                    if (playerBox.intersectsBox(blockBox)) {
                        const deltaX = playerPos.x - (x + BLOCK_SIZE / 2); const deltaY = playerPos.y - (y + BLOCK_SIZE / 2); const deltaZ = playerPos.z - (z + BLOCK_SIZE / 2);
                        const penetrationX = (playerWidth / 2 + BLOCK_SIZE / 2) - Math.abs(deltaX); const penetrationY = (PLAYER_HEIGHT / 2 + BLOCK_SIZE / 2) - Math.abs(deltaY); const penetrationZ = (playerWidth / 2 + BLOCK_SIZE / 2) - Math.abs(deltaZ);
                        if (penetrationY < penetrationX && penetrationY < penetrationZ) {
                            if (deltaY > 0) { // Colliding from top
                                playerPos.y = blockBox.max.y + playerHalfHeight;
                                if (velocity.y < 0) {
                                     velocity.y = 0;
                                     onGround = true;
                                     groundBlockType = blockType; // Store ground block type
                                }
                            } else { // Colliding from bottom
                                playerPos.y = blockBox.min.y - playerHalfHeight; if (velocity.y > 0) { velocity.y = 0; }
                            }
                        } else if (penetrationX < penetrationZ) { /* X collision */ if (deltaX > 0) { playerPos.x = blockBox.max.x + playerWidth / 2; } else { playerPos.x = blockBox.min.x - playerWidth / 2; } velocity.x = 0; }
                        else { /* Z collision */ if (deltaZ > 0) { playerPos.z = blockBox.max.z + playerWidth / 2; } else { playerPos.z = blockBox.min.z - playerWidth / 2; } velocity.z = 0; }
                        controls.getObject().position.set(playerPos.x, playerPos.y, playerPos.z);
                    }
                }
            }}}
            canJump = onGround;
            if (didJump) { playSound('jump', 'C5', '16n'); }

            // --- Footstep Sounds ---
            const now = performance.now() / 1000; // Time in seconds
            if (horizontalMovement && onGround && groundBlockType && (now - lastFootstepTime > footstepCooldown)) {
                 const groundBlockData = blockTypes[groundBlockType];
                 playBlockSound('footstep', groundBlockData?.soundType || 'default');
                 lastFootstepTime = now;
            }
            // --- End Footstep Sounds ---

            if (playerPos.y < -20) { playerPos.set(WORLD_SIZE_X / 2, WORLD_SIZE_Y + PLAYER_HEIGHT, WORLD_SIZE_Z / 2); velocity.set(0, 0, 0); showMessage("Fell out of the world!"); }
        }


        // --- Interaction & Breaking ---
        function checkInteraction() { /* ... same as before ... */ if (!controls.isLocked) { if (isBreaking) resetBreakingState(); highlightMesh.visible = false; currentIntersected = null; return; } raycaster.setFromCamera({ x: 0, y: 0 }, camera); const intersects = raycaster.intersectObjects(objects, false); const previouslyIntersected = currentIntersected; currentIntersected = null; let intersectedBlockMesh = null; if (intersects.length > 0) { for (let i = 0; i < intersects.length; i++) { if (intersects[i].distance < REACH_DISTANCE) { const obj = intersects[i].object; if (obj.userData && obj.userData.x !== undefined) { intersectedBlockMesh = obj; currentIntersected = obj.userData; break; } } } } if (intersectedBlockMesh) { if (isBreaking && currentBreakingBlock !== intersectedBlockMesh) { resetBreakingState(); } if (previouslyIntersected?.x !== currentIntersected.x || previouslyIntersected?.y !== currentIntersected.y || previouslyIntersected?.z !== currentIntersected.z) { highlightMesh.position.copy(intersectedBlockMesh.position); highlightMesh.visible = true; if (isBreaking) resetBreakingState(); } } else { highlightMesh.visible = false; if (isBreaking) resetBreakingState(); currentIntersected = null; } if (isBreaking) { highlightMaterial.opacity = 0.2 + (0.6 * breakProgress); } else { highlightMaterial.opacity = 0.5; } }
        function placeBlock() { /* ... same as before ... */ if (!controls.isLocked || !currentIntersected) return; const targetMesh = objects.find(obj => obj.userData.x === currentIntersected.x && obj.userData.y === currentIntersected.y && obj.userData.z === currentIntersected.z); if (!targetMesh) return; raycaster.setFromCamera({ x: 0, y: 0 }, camera); const intersects = raycaster.intersectObject(targetMesh, false); if (!intersects || intersects.length === 0 || !intersects[0].face) { console.warn("Placement failed: No face normal."); return; } const face = intersects[0].face; const normal = face.normal.clone(); const blockPos = currentIntersected; const newBlockPos = { x: blockPos.x + Math.round(normal.x), y: blockPos.y + Math.round(normal.y), z: blockPos.z + Math.round(normal.z) }; const playerPos = controls.getObject().position; const playerBox = new THREE.Box3().setFromCenterAndSize(playerPos, new THREE.Vector3(0.8, PLAYER_HEIGHT, 0.8)); const newBlockBox = new THREE.Box3(new THREE.Vector3(newBlockPos.x, newBlockPos.y, newBlockPos.z), new THREE.Vector3(newBlockPos.x + BLOCK_SIZE, newBlockPos.y + BLOCK_SIZE, newBlockPos.z + BLOCK_SIZE)); if (playerBox.intersectsBox(newBlockBox)) { console.log("Cannot place block inside player."); return; } addBlock(newBlockPos.x, newBlockPos.y, newBlockPos.z, selectedBlockType); }
        function startBreaking() { /* ... same as before ... */ if (!controls.isLocked || !currentIntersected || isBreaking) return; const targetMesh = objects.find(obj => obj.userData.x === currentIntersected.x && obj.userData.y === currentIntersected.y && obj.userData.z === currentIntersected.z); if (!targetMesh) return; isBreaking = true; breakStartTime = performance.now(); currentBreakingBlock = targetMesh; breakProgress = 0; console.log("Start breaking:", currentIntersected); }
        function stopBreaking() { /* ... same as before ... */ if (isBreaking) { console.log("Stop breaking"); resetBreakingState(); } }
        function resetBreakingState() { /* ... same as before ... */ isBreaking = false; breakStartTime = 0; currentBreakingBlock = null; breakProgress = 0; highlightMaterial.opacity = 0.5; }
        function updateBreaking(delta) { /* ... same as before ... */ if (!isBreaking || !currentBreakingBlock || !currentIntersected) { resetBreakingState(); return; } if (currentIntersected.x !== currentBreakingBlock.userData.x || currentIntersected.y !== currentBreakingBlock.userData.y || currentIntersected.z !== currentBreakingBlock.userData.z) { resetBreakingState(); return; } const blockData = blockTypes[currentBreakingBlock.userData.type]; const requiredTime = blockData?.breakTime || 1.0; breakProgress += delta / requiredTime; breakProgress = Math.min(breakProgress, 1.0); if (breakProgress >= 1.0) { console.log("Block broken!"); const blockCoords = currentBreakingBlock.userData; removeBlock(blockCoords.x, blockCoords.y, blockCoords.z); resetBreakingState(); checkInteraction(); } }

        // --- Gravity ---
        // (scheduleGravityCheck, processGravityQueue functions remain the same)
        function scheduleGravityCheck(x, y, z) { const key = getBlockKey(x, y, z); const blockType = getBlock(x, y, z); if (blockType && blockTypes[blockType]?.hasGravity) { gravityCheckQueue.add(key); } }
        function processGravityQueue() { if (gravityCheckQueue.size === 0) return; const blocksToProcess = Array.from(gravityCheckQueue); gravityCheckQueue.clear(); blocksToProcess.forEach(key => { const coords = key.split(',').map(Number); const [x, y, z] = coords; const blockType = getBlock(x, y, z); const blockData = blockTypes[blockType]; if (!blockData || !blockData.hasGravity) return; const belowKey = getBlockKey(x, y - 1, z); const belowType = world[belowKey]; if (y > 0 && !belowType) { console.log(`Gravity: Block at ${key} is falling.`); const success = removeBlock(x, y, z, false); if (success) { addBlock(x, y - 1, z, blockType, false); scheduleGravityCheck(x, y + 1, z); scheduleGravityCheck(x + 1, y - 1, z); scheduleGravityCheck(x - 1, y - 1, z); scheduleGravityCheck(x, y - 1, z + 1); scheduleGravityCheck(x, y - 1, z - 1); } } }); }

        // --- Day/Night Cycle ---
        function updateDayNightCycle(delta) {
            timeOfDay = (timeOfDay + delta / DAY_CYCLE_DURATION) % 1.0; // Cycle time 0 to 1

            // Calculate cycle progress (0 = midnight, 0.5 = noon, 1 = midnight)
            const cyclePos = Math.sin(timeOfDay * Math.PI * 2); // -1 to 1, noon is 1, midnight is -1
            const noonFactor = (cyclePos + 1) / 2; // 0 to 1, noon is 1, midnight is 0
            const duskDawnFactor = Math.sin(timeOfDay * Math.PI); // 0 to 1, peaks at noon, 0 at midnight/sunrise/sunset

            // Interpolate Sky Color
            const currentSkyColor = skyColorNight.clone().lerp(skyColorDay, noonFactor);
            scene.background = currentSkyColor;

            // Interpolate Fog Color
             const currentFogColor = fogColorNight.clone().lerp(fogColorDay, noonFactor);
             if (!scene.fog) { // Initialize fog if it doesn't exist
                 scene.fog = new THREE.Fog(currentFogColor, 10, 100);
             } else {
                 scene.fog.color.copy(currentFogColor);
                 scene.fog.near = 10 + 60 * (1 - duskDawnFactor); // Fog closer at night
                 scene.fog.far = 75 + 50 * duskDawnFactor; // Fog further during day
             }


            // Interpolate Lighting
            const ambientLight = scene.children.find(obj => obj.isAmbientLight);
            const directionalLight = scene.children.find(obj => obj.isDirectionalLight);

            if (ambientLight) {
                const ambientIntensity = 0.1 + 0.5 * noonFactor; // Brighter during day
                ambientLight.intensity = ambientIntensity;
                ambientLight.color.copy(lightColorNight.clone().lerp(lightColorDay, duskDawnFactor));
            }
            if (directionalLight) {
                 const directionalIntensity = Math.max(0, 0.9 * duskDawnFactor); // Stronger sunlight during day
                 directionalLight.intensity = directionalIntensity;
                 directionalLight.color.copy(lightColorNight.clone().lerp(lightColorDay, duskDawnFactor));
                 // Optional: Move the sun
                 directionalLight.position.set(Math.cos(timeOfDay * Math.PI * 2) * 100, Math.sin(timeOfDay * Math.PI * 2) * 100, 50).normalize();
                 directionalLight.position.multiplyScalar(200); // Keep it distant
            }
        }

        // --- Event Handlers ---
        function onKeyDown(event) { if (!controls.isLocked && event.code !== 'Escape') return; switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = true; break; case 'ArrowLeft': case 'KeyA': moveLeft = true; break; case 'ArrowDown': case 'KeyS': moveBackward = true; break; case 'ArrowRight': case 'KeyD': moveRight = true; break; case 'Space': moveUp = true; break; case 'ShiftLeft': case 'ShiftRight': moveDown = true; break; case 'Escape': if (controls.isLocked) controls.unlock(); break;
            // Use digits 1-9 for hotbar selection
            case 'Digit1': selectHotbarSlot(0); break; case 'Digit2': selectHotbarSlot(1); break; case 'Digit3': selectHotbarSlot(2); break;
            case 'Digit4': selectHotbarSlot(3); break; case 'Digit5': selectHotbarSlot(4); break; case 'Digit6': selectHotbarSlot(5); break;
            case 'Digit7': selectHotbarSlot(6); break; case 'Digit8': selectHotbarSlot(7); break; case 'Digit9': selectHotbarSlot(8); break;
        } }
        function onKeyUp(event) { switch (event.code) { case 'ArrowUp': case 'KeyW': moveForward = false; break; case 'ArrowLeft': case 'KeyA': moveLeft = false; break; case 'ArrowDown': case 'KeyS': moveBackward = false; break; case 'ArrowRight': case 'KeyD': moveRight = false; break; case 'Space': moveUp = false; break; case 'ShiftLeft': case 'ShiftRight': moveDown = false; break; } }
        function onMouseDown(event) { if (!controls.isLocked) return; switch (event.button) { case 0: startBreaking(); break; case 2: placeBlock(); break; } }
        function onMouseUp(event) { if (!controls.isLocked) return; if (event.button === 0) { stopBreaking(); } }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Hotbar UI ---
        function setupHotbar() {
            const hotbarDiv = document.getElementById('hotbar');
            hotbarDiv.innerHTML = ''; // Clear previous
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.classList.add('hotbar-slot');
                slot.dataset.index = i;

                const blockType = hotbarBlocks[i]; // Get block type for this slot
                const blockData = blockTypes[blockType];

                if (blockData) {
                    // Add a small preview div inside the slot
                    const preview = document.createElement('div');
                    preview.classList.add('block-preview');
                    preview.style.backgroundColor = `#${(blockData.topColor || blockData.color).toString(16).padStart(6, '0')}`;
                    if (blockData.transparent) preview.style.opacity = '0.7';
                    slot.appendChild(preview);
                    slot.title = blockData.name; // Tooltip
                }

                // Add slot number
                const number = document.createElement('span');
                number.classList.add('slot-number');
                number.textContent = (i + 1);
                slot.appendChild(number);


                if (i === selectedHotbarIndex) {
                    slot.classList.add('selected');
                }

                slot.addEventListener('click', () => {
                    selectHotbarSlot(i);
                });
                hotbarDiv.appendChild(slot);
            }
             // Add scroll wheel listener for hotbar selection
             window.addEventListener('wheel', (event) => {
                 if (!controls.isLocked) return; // Only change slot if locked? Or allow always? Let's allow always.
                 let nextIndex;
                 if (event.deltaY < 0) { // Scroll up
                     nextIndex = (selectedHotbarIndex - 1 + 9) % 9;
                 } else { // Scroll down
                     nextIndex = (selectedHotbarIndex + 1) % 9;
                 }
                 selectHotbarSlot(nextIndex);
             }, { passive: true });
        }

        function selectHotbarSlot(index) {
            if (index < 0 || index > 8) return; // Invalid index

            selectedHotbarIndex = index;
            selectedBlockType = hotbarBlocks[selectedHotbarIndex]; // Update the globally selected block type
            console.log(`Selected hotbar slot: ${index + 1}, Block Type: ${selectedBlockType} (${blockTypes[selectedBlockType]?.name})`);

            // Update UI selection indicator
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, i) => {
                slot.classList.toggle('selected', i === selectedHotbarIndex);
            });
        }

        // --- Collected Blocks UI ---
        function updateCollectedUI() {
            const counterDiv = document.getElementById('collected-counter');
            let html = "Collected:<br>";
            // Sort by type ID for consistent order
            const sortedTypes = Object.keys(collectedBlocks).map(Number).sort((a, b) => a - b);

            for (const typeId of sortedTypes) {
                const count = collectedBlocks[typeId];
                if (count > 0) {
                     const blockData = blockTypes[typeId];
                     const name = blockData ? blockData.name : `Unknown (${typeId})`;
                     html += `<div>${name}: ${count}</div>`;
                }
            }
            counterDiv.innerHTML = html;
        }


        // --- Message Box ---
        let messageTimeout; function showMessage(text, duration = 2000) { const messageBox = document.getElementById('message-box'); const messageText = document.getElementById('message-text'); messageText.textContent = text; messageBox.style.display = 'block'; if (messageTimeout) clearTimeout(messageTimeout); messageTimeout = null; if (duration > 0) { messageTimeout = setTimeout(hideMessage, duration); } document.getElementById('message-ok').onclick = hideMessage; } function hideMessage() { if (messageTimeout) { clearTimeout(messageTimeout); messageTimeout = null; } document.getElementById('message-box').style.display = 'none'; document.getElementById('message-ok').onclick = null; }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            if (delta > 0 && delta < 1.0) {
                 updatePlayer(delta);
                 checkInteraction();
                 if (isBreaking) { updateBreaking(delta); }
                 processGravityQueue();
                 updateDayNightCycle(delta); // Update day/night cycle
            }
            try { renderer.render(scene, camera); }
            catch(e) { console.error("Render error:", e); }
        }

        // --- Start ---
        window.onload = function() { if (typeof THREE === 'undefined') { console.error("THREE not defined."); alert("Error: Load Three.js failed."); return; } if (typeof THREE.PointerLockControls === 'undefined') { console.error("PointerLockControls not defined."); alert("Error: Load PointerLockControls failed."); return; } if (typeof Tone === 'undefined') { console.error("Tone.js not defined."); alert("Error: Load Tone.js failed."); return; } try { init(); animate(); } catch (error) { console.error("Init/Anim failed:", error); alert(`Error: ${error.message}.`); } }

    </script>
</body>
</html>
