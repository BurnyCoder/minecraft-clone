<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Sandbox - Textures & Terrain</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #77b6e0; color: white; }
        canvas { display: block; width: 100%; height: 100%; }
        #instructions { position: absolute; top: 10px; left: 10px; background-color: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; font-size: 14px; z-index: 10; color: white; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border: 1px solid white; transform: translate(-50%, -50%); pointer-events: none; z-index: 10; box-sizing: border-box; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background-color: white; }
        #crosshair::before { left: 50%; top: -3px; width: 1px; height: 16px; transform: translateX(-50%); }
        #crosshair::after { top: 50%; left: -3px; width: 16px; height: 1px; transform: translateY(-50%); }
        #block-selector { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.4); padding: 5px; border: 2px solid #555; border-radius: 3px; display: flex; gap: 5px; z-index: 10; }
        .block-option {
            width: 50px; height: 50px; border: 2px solid #888; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 10px; text-align: center; user-select: none;
            background-size: cover; image-rendering: pixelated; box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            /* Use canvas generated background for preview */
            background-repeat: no-repeat; background-position: center;
        }
        .block-option.selected { border-color: white; box-shadow: inset 0 0 10px rgba(255,255,255,0.7); }
        /* CSS classes match block types for potential styling/preview */
        .grass {} .dirt {} .stone {} .wood {} .leaves {} .sand {} .glass {}
    </style>
</head>
<body>
    <div id="instructions">
        Click to start (Sound requires interaction)<br>
        WASD: Move | Space: Jump | Mouse: Look<br>
        L-Click: Remove Block | R-Click: Place Block<br>
        1-7: Select Block Type
    </div>
    <div id="crosshair"></div>
    <div id="block-selector">
        <div class="block-option grass selected" data-type="grass">Grass (1)</div>
        <div class="block-option dirt" data-type="dirt">Dirt (2)</div>
        <div class="block-option stone" data-type="stone">Stone (3)</div>
        <div class="block-option wood" data-type="wood">Wood (4)</div>
        <div class="block-option leaves" data-type="leaves">Leaves (5)</div>
        <div class="block-option sand" data-type="sand">Sand (6)</div>
        <div class="block-option glass" data-type="glass">Glass (7)</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <script>
        // Ensure libraries are loaded
        if (typeof THREE === 'undefined' || typeof Tone === 'undefined') {
            console.error("Required library not found.");
            document.getElementById('instructions').innerHTML = "Error: Could not load libraries.";
        } else {
            // --- Tone.js Setup ---
            // (Sound setup remains the same as previous version)
            const synth = new Tone.Synth().toDestination();
            const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.1 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 0.5 }).toDestination();
            metalSynth.volume.value = -15;
            function playSound(type) {
                if (Tone.context.state !== 'running') { Tone.start(); }
                try {
                    if (type === 'place') synth.triggerAttackRelease("C4", "16n");
                    else if (type === 'break') metalSynth.triggerAttackRelease("8n");
                    else if (type === 'jump') synth.triggerAttackRelease("E4", "16n", Tone.now(), 0.5);
                } catch (error) { console.error("Tone.js error:", error); }
            }

            // --- Scene, Camera, Renderer, Lighting, Skybox, Clouds ---
            // (Setup remains mostly the same as previous version)
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x77b6e0);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 5); // Start higher due to terrain
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(30, 40, 20); // Adjusted light angle
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 100; // Increased shadow range
            directionalLight.shadow.camera.left = -40; directionalLight.shadow.camera.right = 40;
            directionalLight.shadow.camera.top = 40; directionalLight.shadow.camera.bottom = -40;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);
            // Skybox
            const skyboxSize = 500; const skyboxGeo = new THREE.BoxGeometry(skyboxSize, skyboxSize, skyboxSize);
            const skyboxMaterials = [ new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide }), new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide }), new THREE.MeshBasicMaterial({ color: 0x87cefa, side: THREE.BackSide }), new THREE.MeshBasicMaterial({ color: 0xadd8e6, side: THREE.BackSide }), new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide }), new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide }) ];
            const skybox = new THREE.Mesh(skyboxGeo, skyboxMaterials); scene.add(skybox);
            // Clouds
            const cloudGeo = new THREE.BoxGeometry(6, 1.5, 4); const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 20; i++) { const cloud = new THREE.Mesh(cloudGeo.clone(), cloudMaterial); cloud.position.set( (Math.random() - 0.5) * 250, Math.random() * 25 + 40, (Math.random() - 0.5) * 250 ); cloud.rotation.y = Math.random() * Math.PI; scene.add(cloud); }

            // --- Player Physics ---
            // (Physics variables remain the same)
            const playerVelocity = new THREE.Vector3(); const playerHeight = 1.8; const playerWidth = 0.6; const playerHalfWidth = playerWidth / 2; const playerHalfHeight = playerHeight / 2; const gravity = -22.0; const jumpForce = 9.0; const worldUp = new THREE.Vector3(0, 1, 0); let playerIsOnGround = false;

            // --- Block Definitions ---
            const blockSize = 1; const blockHalfSize = blockSize / 2;
            const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

            // --- Canvas Texture Generation ---
            const textureCache = {}; // Cache generated textures

            function createBlockTexture(patternType, size = 16) {
                const cacheKey = `${patternType}_${size}`;
                if (textureCache[cacheKey]) {
                    return textureCache[cacheKey];
                }

                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Draw patterns based on type
                switch(patternType) {
                    case 'grass_top':
                        ctx.fillStyle = '#559e55'; ctx.fillRect(0, 0, size, size);
                        ctx.fillStyle = 'rgba(0,0,0,0.1)'; // Add subtle noise
                        for (let i = 0; i < size * 2; i++) ctx.fillRect(Math.random() * size, Math.random() * size, 1, 1);
                        break;
                    case 'grass_side':
                        ctx.fillStyle = '#789c4d'; ctx.fillRect(0, 0, size, size); // Base side color
                        ctx.fillStyle = '#8B4513'; ctx.fillRect(0, size * 0.6, size, size * 0.4); // Dirt bottom part
                        ctx.fillStyle = 'rgba(0,0,0,0.1)'; // Noise
                        for (let i = 0; i < size; i++) ctx.fillRect(Math.random() * size, Math.random() * size, 1, 1);
                        break;
                    case 'dirt':
                        ctx.fillStyle = '#8B4513'; ctx.fillRect(0, 0, size, size);
                        ctx.fillStyle = 'rgba(0,0,0,0.15)'; // Darker noise for dirt
                        for (let i = 0; i < size * 2; i++) ctx.fillRect(Math.random() * size, Math.random() * size, 1, 1);
                        break;
                    case 'stone':
                        ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, size, size);
                        ctx.fillStyle = 'rgba(0,0,0,0.2)'; // Stone noise
                        for (let i = 0; i < size * 3; i++) ctx.fillRect(Math.random() * size, Math.random() * size, Math.random() > 0.5 ? 2:1, Math.random() > 0.5 ? 2:1);
                        break;
                    case 'wood_side': // Bark texture
                        ctx.fillStyle = '#6e4d2e'; ctx.fillRect(0, 0, size, size);
                        ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = Math.max(1, size / 8);
                        for(let i=0; i < 3; i++) { ctx.beginPath(); ctx.moveTo(Math.random()*size*0.4 + size*0.3, 0); ctx.lineTo(Math.random()*size*0.4 + size*0.3, size); ctx.stroke(); }
                        break;
                    case 'wood_top': // Rings texture
                        ctx.fillStyle = '#ab8860'; ctx.fillRect(0, 0, size, size);
                        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = Math.max(1, size / 16);
                        for(let r=size*0.1; r < size*0.5; r += size*0.15) { ctx.beginPath(); ctx.arc(size/2, size/2, r, 0, Math.PI*2); ctx.stroke(); }
                        break;
                    case 'leaves':
                        ctx.fillStyle = '#3a7d44'; ctx.fillRect(0, 0, size, size);
                        ctx.fillStyle = 'rgba(0,0,0,0.2)'; // Darker spots
                        for (let i = 0; i < size * 2; i++) ctx.fillRect(Math.random() * size, Math.random() * size, 2, 2);
                        break;
                    case 'sand':
                        ctx.fillStyle = '#f4a460'; ctx.fillRect(0, 0, size, size); // SandyBrown
                        ctx.fillStyle = 'rgba(0,0,0,0.08)'; // Sand grain noise
                        for (let i = 0; i < size * 4; i++) ctx.fillRect(Math.random() * size, Math.random() * size, 1, 1);
                        break;
                     case 'glass':
                        ctx.fillStyle = 'rgba(220, 235, 245, 0.5)'; ctx.fillRect(0, 0, size, size); // Light blueish tint, semi-transparent
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = Math.max(1, size/16); // Subtle border/highlight
                        ctx.strokeRect(0, 0, size, size);
                        ctx.beginPath(); ctx.moveTo(size*0.1, size*0.1); ctx.lineTo(size*0.3, size*0.1); ctx.stroke(); // Corner highlight
                        break;
                    default: // Fallback grey
                        ctx.fillStyle = '#555555'; ctx.fillRect(0, 0, size, size);
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.magFilter = THREE.NearestFilter; // Pixelated look
                texture.minFilter = THREE.NearestFilter;
                texture.needsUpdate = true;

                textureCache[cacheKey] = texture; // Store in cache

                // Add texture preview to hotbar item background
                const hotbarItem = document.querySelector(`.block-option.${patternType.split('_')[0]}`);
                if (hotbarItem) {
                     // Only set background for primary type (e.g., grass, not grass_top)
                     if (!patternType.includes('_') || patternType === 'grass_top') {
                          hotbarItem.style.backgroundImage = `url(${canvas.toDataURL()})`;
                          hotbarItem.style.backgroundSize = '80%'; // Don't let it fill entirely
                     }
                }


                return texture;
            }

            // --- Materials Definition (Using Canvas Textures) ---
            // Order: +X (right), -X (left), +Y (top), -Y (bottom), +Z (front), -Z (back)
            const materials = {
                grass: [ // Array for multi-face materials
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('grass_side') }), // Right
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('grass_side') }), // Left
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('grass_top') }),  // Top
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('dirt') }),      // Bottom
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('grass_side') }), // Front
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('grass_side') })  // Back
                ],
                dirt: new THREE.MeshLambertMaterial({ map: createBlockTexture('dirt') }),
                stone: new THREE.MeshLambertMaterial({ map: createBlockTexture('stone') }),
                wood: [
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('wood_side') }), // Right
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('wood_side') }), // Left
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('wood_top') }),  // Top
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('wood_top') }),  // Bottom
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('wood_side') }), // Front
                    new THREE.MeshLambertMaterial({ map: createBlockTexture('wood_side') })  // Back
                ],
                leaves: new THREE.MeshLambertMaterial({ map: createBlockTexture('leaves'), transparent: true, alphaTest: 0.1 }), // alphaTest helps with leaf rendering order
                sand: new THREE.MeshLambertMaterial({ map: createBlockTexture('sand') }),
                glass: new THREE.MeshLambertMaterial({ map: createBlockTexture('glass'), transparent: true, opacity: 0.6, side: THREE.DoubleSide }) // DoubleSide to see through
            };

            function getBlockMaterial(type) { return materials[type] || materials.stone; }
            let selectedBlockType = 'grass';

            // --- World Generation (Simple Height Variation) ---
            const worldSize = 24; // Larger world
            const terrainBaseLevel = -2;
            const terrainHeightRange = 5; // Max height variation
            const objects = []; // Interactive blocks

            // Store height data for simple smoothing (optional)
            const heightMap = {};
            function getHeight(x, z) {
                 const key = `${x},${z}`;
                 if (heightMap[key] === undefined) {
                      // Very basic noise: average random with neighbors if they exist
                      const neighbors = [
                           heightMap[`${x-1},${z}`], heightMap[`${x},${z-1}`]
                      ].filter(h => h !== undefined);
                      let h = terrainBaseLevel + Math.floor(Math.random() * terrainHeightRange);
                      if (neighbors.length > 0) {
                           const avgNeighbor = neighbors.reduce((a, b) => a + b, 0) / neighbors.length;
                           h = Math.round(avgNeighbor * 0.5 + h * 0.5); // Simple smoothing
                      }
                       // Clamp height within reasonable bounds
                      h = Math.max(terrainBaseLevel, Math.min(terrainBaseLevel + terrainHeightRange -1, h));
                      heightMap[key] = h;
                 }
                 return heightMap[key];
            }


            console.log("Generating world...");
            for (let x = -worldSize / 2; x < worldSize / 2; x++) {
                for (let z = -worldSize / 2; z < worldSize / 2; z++) {
                    const yMax = getHeight(x,z); // Determine max height for this column

                    for (let y = terrainBaseLevel - 3; y <= yMax; y++) { // Generate from bedrock up to yMax
                        let blockType;
                        if (y === yMax) {
                            blockType = 'grass';
                        } else if (y >= yMax - 2) { // 2 layers of dirt below grass
                            blockType = 'dirt';
                        } else {
                            blockType = 'stone'; // Stone below dirt
                        }

                        const blockMaterial = getBlockMaterial(blockType);
                        // Use InstancedMesh or MergedGeometry for large worlds, but Mesh is ok for now
                        const block = new THREE.Mesh(blockGeometry, blockMaterial);
                        block.position.set(x + blockHalfSize, y + blockHalfSize, z + blockHalfSize); // Position center
                        block.castShadow = true;
                        block.receiveShadow = true;
                        block.userData.blockType = blockType;
                        scene.add(block);
                        objects.push(block);
                    }
                }
            }
            console.log("World generated. Block count:", objects.length);

            // Adjust initial camera height based on terrain at spawn
            const spawnHeight = getHeight(0,0); // Get height at (0,0)
            camera.position.y = spawnHeight + 1 + playerHeight; // Start above ground level
            camera.position.x = 0.5; // Center in block
            camera.position.z = 0.5;

            // --- Controls ---
            // (Control state and variables remain the same)
             const controls = { forward: false, backward: false, left: false, right: false, jump: false };
             let moveSpeed = 5.5; let mouseSensitivity = 0.002; let isPointerLocked = false;
             const euler = new THREE.Euler(0, 0, 0, 'YXZ');

            // --- Event Listeners (Add keys 6, 7) ---
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': controls.forward = true; break;
                    case 'KeyS': case 'ArrowDown': controls.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': controls.left = true; break;
                    case 'KeyD': case 'ArrowRight': controls.right = true; break;
                    case 'Space': if (playerIsOnGround && !controls.jump) { controls.jump = true; playSound('jump'); } break;
                    case 'Digit1': selectBlock('grass'); break;
                    case 'Digit2': selectBlock('dirt'); break;
                    case 'Digit3': selectBlock('stone'); break;
                    case 'Digit4': selectBlock('wood'); break;
                    case 'Digit5': selectBlock('leaves'); break;
                    case 'Digit6': selectBlock('sand'); break; // Added Sand
                    case 'Digit7': selectBlock('glass'); break; // Added Glass
                }
            });
            // (keyup, mousemove, click, pointerlockchange, pointerlockerror, contextmenu remain the same)
            document.addEventListener('keyup', (event) => { /* ... same as before ... */ switch (event.code) { case 'KeyW': case 'ArrowUp': controls.forward = false; break; case 'KeyS': case 'ArrowDown': controls.backward = false; break; case 'KeyA': case 'ArrowLeft': controls.left = false; break; case 'KeyD': case 'ArrowRight': controls.right = false; break; } });
            document.addEventListener('mousemove', (event) => { if (!isPointerLocked) return; euler.setFromQuaternion(camera.quaternion); euler.y -= event.movementX * mouseSensitivity; euler.x -= event.movementY * mouseSensitivity; euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); camera.quaternion.setFromEuler(euler); });
            document.body.addEventListener('click', () => { if (!isPointerLocked) { Tone.start(); document.body.requestPointerLock().catch(err => console.error('Pointer Lock request failed:', err)); } });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === document.body; document.getElementById('instructions').style.display = isPointerLocked ? 'none' : 'block'; });
            document.addEventListener('pointerlockerror', (error) => { console.error('Pointer Lock Error:', error); document.getElementById('instructions').innerHTML = "Pointer Lock Failed."; });
            document.body.addEventListener('contextmenu', (event) => event.preventDefault());

            // --- Block Interaction (Raycasting, Placement, Removal) ---
            // (Logic remains mostly the same, ensure material handling is correct)
            const raycaster = new THREE.Raycaster(); const clickMaxDistance = 6;
            document.addEventListener('mousedown', (event) => {
                if (!isPointerLocked) return;
                raycaster.setFromCamera({ x: 0, y: 0 }, camera);
                const intersects = raycaster.intersectObjects(objects, false);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    if (intersect.distance > clickMaxDistance) return;

                    if (event.button === 0) { // Left Click: Remove
                        // Prevent removing lowest stone layer (like bedrock)
                        if (intersect.object.position.y <= terrainBaseLevel - 3 + blockHalfSize + 0.1) return;

                        playSound('break');
                        scene.remove(intersect.object);
                        const index = objects.indexOf(intersect.object); if (index > -1) objects.splice(index, 1);
                        // Geometry is shared, materials might be arrays or single - handle disposal carefully if needed, but often not required for shared materials.

                    } else if (event.button === 2) { // Right Click: Place
                        const blockMaterial = getBlockMaterial(selectedBlockType);
                        if (!blockMaterial) return;

                        // Use the shared geometry
                        const voxel = new THREE.Mesh(blockGeometry, blockMaterial);
                        const placementPos = intersect.object.position.clone().add(intersect.face.normal);
                        voxel.position.set( Math.floor(placementPos.x) + blockHalfSize, Math.floor(placementPos.y) + blockHalfSize, Math.floor(placementPos.z) + blockHalfSize );

                        // Collision checks (player, existing block)
                        const playerBox = new THREE.Box3().setFromCenterAndSize( new THREE.Vector3(camera.position.x, camera.position.y - playerHalfHeight, camera.position.z), new THREE.Vector3(playerWidth, playerHeight, playerWidth) );
                        const blockBox = new THREE.Box3().setFromCenterAndSize( voxel.position, new THREE.Vector3(blockSize, blockSize, blockSize) );
                        const positionOccupied = objects.some(obj => obj.position.distanceToSquared(voxel.position) < 0.1);

                        if (playerBox.intersectsBox(blockBox)) { return; }
                        if (positionOccupied) { return; }

                        playSound('place');
                        voxel.castShadow = true; voxel.receiveShadow = true;
                        voxel.userData.blockType = selectedBlockType;
                        scene.add(voxel); objects.push(voxel);
                    }
                }
            });

            // --- Block Selector UI Update ---
            const blockOptions = document.querySelectorAll('.block-option');
            function selectBlock(type) {
                if (!materials[type]) return;
                selectedBlockType = type;
                blockOptions.forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.type === type) option.classList.add('selected');
                });
            }
            blockOptions.forEach(option => { option.addEventListener('click', (e) => { e.stopPropagation(); selectBlock(option.dataset.type); }); });

            // --- Resize Handling ---
            // (Remains the same)
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

            // --- Game Loop (Physics and Rendering) ---
            // (Physics/Movement/Collision/Jump logic remains the same as the previous fixed version)
            const clock = new THREE.Clock(); const moveDirection = new THREE.Vector3(); const rightDirection = new THREE.Vector3(); const finalMove = new THREE.Vector3();
            function animate() {
                requestAnimationFrame(animate);
                const delta = Math.min(clock.getDelta(), 0.05);

                // Movement Calculation
                playerVelocity.x = 0; playerVelocity.z = 0;
                camera.getWorldDirection(moveDirection).y = 0; moveDirection.normalize();
                rightDirection.crossVectors(moveDirection, worldUp).normalize();
                let moveX = 0, moveZ = 0;
                if (controls.forward) moveZ += 1; if (controls.backward) moveZ -= 1;
                if (controls.left) moveX -= 1; if (controls.right) moveX += 1;
                finalMove.set(0,0,0); finalMove.addScaledVector(rightDirection, moveX); finalMove.addScaledVector(moveDirection, moveZ);
                if (finalMove.lengthSq() > 1.1) finalMove.normalize();
                playerVelocity.x = finalMove.x * moveSpeed; playerVelocity.z = finalMove.z * moveSpeed;

                // Physics Update (Gravity, Collision)
                playerVelocity.y += gravity * delta;
                const deltaPosition = playerVelocity.clone().multiplyScalar(delta);
                const currentPosition = camera.position.clone();
                const nextPosition = currentPosition.clone().add(deltaPosition);
                playerIsOnGround = false;
                for (const block of objects) { // Simplified collision loop
                    const blockPos = block.position; const blockMin = blockPos.clone().subScalar(blockHalfSize); const blockMax = blockPos.clone().addScalar(blockHalfSize);
                    const playerMin = new THREE.Vector3(nextPosition.x - playerHalfWidth, nextPosition.y - playerHalfHeight, nextPosition.z - playerHalfWidth);
                    const playerMax = new THREE.Vector3(nextPosition.x + playerHalfWidth, nextPosition.y + playerHalfHeight, nextPosition.z + playerHalfWidth);
                    if (playerMax.x > blockMin.x && playerMin.x < blockMax.x && playerMax.y > blockMin.y && playerMin.y < blockMax.y && playerMax.z > blockMin.z && playerMin.z < blockMax.z) {
                        const overlapX1 = playerMax.x - blockMin.x, overlapX2 = blockMax.x - playerMin.x; const overlapY1 = playerMax.y - blockMin.y, overlapY2 = blockMax.y - playerMin.y; const overlapZ1 = playerMax.z - blockMin.z, overlapZ2 = blockMax.z - playerMin.z;
                        const minOverlapX = Math.min(overlapX1, overlapX2), minOverlapY = Math.min(overlapY1, overlapY2), minOverlapZ = Math.min(overlapZ1, overlapZ2);
                        if (minOverlapY < minOverlapX && minOverlapY < minOverlapZ) { if (overlapY1 < overlapY2) { nextPosition.y = blockMin.y - playerHalfHeight; if (playerVelocity.y > 0) playerVelocity.y = 0; } else { nextPosition.y = blockMax.y + playerHalfHeight; if (playerVelocity.y < 0) { playerVelocity.y = 0; playerIsOnGround = true; } } }
                        else if (minOverlapX < minOverlapZ) { if (overlapX1 < overlapX2) { nextPosition.x = blockMin.x - playerHalfWidth; } else { nextPosition.x = blockMax.x + playerHalfWidth; } if (Math.abs(playerVelocity.x) > 0.01) playerVelocity.x = 0; }
                        else { if (overlapZ1 < overlapZ2) { nextPosition.z = blockMin.z - playerHalfWidth; } else { nextPosition.z = blockMax.z + playerHalfWidth; } if (Math.abs(playerVelocity.z) > 0.01) playerVelocity.z = 0; }
                    }
                }
                camera.position.copy(nextPosition);

                // Handle Jumping
                if (controls.jump && playerIsOnGround) { playerVelocity.y = jumpForce; controls.jump = false; playerIsOnGround = false; }
                if (!playerIsOnGround) { controls.jump = false; }

                // Prevent Falling
                if (camera.position.y < terrainBaseLevel - 20) { const resetHeight = getHeight(Math.round(camera.position.x), Math.round(camera.position.z)); camera.position.set(camera.position.x, resetHeight + playerHeight + 1, camera.position.z); playerVelocity.set(0, 0, 0); playerIsOnGround = false; }

                // Update Skybox
                skybox.position.copy(camera.position);

                // Render
                renderer.render(scene, camera);
            }

            // Start
            window.onload = () => { animate(); };
        }
    </script>
</body>
</html>
